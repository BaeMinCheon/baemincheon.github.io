<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R2P265ZP7M"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-R2P265ZP7M');
</script>
<!-- End Google Analytics -->


  
  <title>How the text wrap works in UnrealEngine | LET US GO ABROAD</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Environment     UnrealEngine branch: 5.0   Visual Studio 2022 version: 17.1.1   Windows 11 Pro build: 22000.556   Overview  A TextBlock has an option AutoWrapText and the option makes the TextBlock">
<meta property="og:type" content="article">
<meta property="og:title" content="How the text wrap works in UnrealEngine">
<meta property="og:url" content="https://baemincheon.github.io/2022/03/22/how-the-text-wrap-works-in-unrealengine/index.html">
<meta property="og:site_name" content="LET US GO ABROAD">
<meta property="og:description" content="Environment     UnrealEngine branch: 5.0   Visual Studio 2022 version: 17.1.1   Windows 11 Pro build: 22000.556   Overview  A TextBlock has an option AutoWrapText and the option makes the TextBlock">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://baemincheon.github.io/2022/03/22/how-the-text-wrap-works-in-unrealengine/01.png">
<meta property="og:image" content="https://baemincheon.github.io/2022/03/22/how-the-text-wrap-works-in-unrealengine/02.png">
<meta property="og:image" content="https://baemincheon.github.io/2022/03/22/how-the-text-wrap-works-in-unrealengine/03.png">
<meta property="og:image" content="https://baemincheon.github.io/2022/03/22/how-the-text-wrap-works-in-unrealengine/04.png">
<meta property="og:image" content="https://baemincheon.github.io/2022/03/22/how-the-text-wrap-works-in-unrealengine/05.png">
<meta property="og:image" content="https://baemincheon.github.io/2022/03/22/how-the-text-wrap-works-in-unrealengine/07.png">
<meta property="og:image" content="https://baemincheon.github.io/2022/03/22/how-the-text-wrap-works-in-unrealengine/06.png">
<meta property="og:image" content="https://baemincheon.github.io/2022/03/22/how-the-text-wrap-works-in-unrealengine/08.png">
<meta property="og:image" content="https://baemincheon.github.io/2022/03/22/how-the-text-wrap-works-in-unrealengine/09.png">
<meta property="article:published_time" content="2022-03-21T15:07:38.000Z">
<meta property="article:modified_time" content="2022-03-21T15:07:38.000Z">
<meta property="article:author" content="MinCheon Bae">
<meta property="article:tag" content="UnrealEngine">
<meta property="article:tag" content="TextBlock">
<meta property="article:tag" content="TextWrap">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://baemincheon.github.io/2022/03/22/how-the-text-wrap-works-in-unrealengine/01.png">
  
    <link rel="alternate" href="/atom.xml" title="LET US GO ABROAD" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LET US GO ABROAD</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/2020/02/03/home-page/index.html">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://baemincheon.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-how-the-text-wrap-works-in-unrealengine" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/22/how-the-text-wrap-works-in-unrealengine/" class="article-date">
  <time datetime="2022-03-21T15:07:38.000Z" itemprop="datePublished">2022-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      How the text wrap works in UnrealEngine
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <table>
<thead>
<tr>
<th>Environment</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>UnrealEngine</td>
<td><code>branch: 5.0</code></td>
</tr>
<tr>
<td>Visual Studio 2022</td>
<td><code>version: 17.1.1</code></td>
</tr>
<tr>
<td>Windows 11 Pro</td>
<td><code>build: 22000.556</code></td>
</tr>
</tbody></table>
<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a><em><code>Overview</code></em></h1><img src="/2022/03/22/how-the-text-wrap-works-in-unrealengine/01.png" class="">

<p>A TextBlock has an option <code>AutoWrapText</code> and the option makes the TextBlock can wrap its text. Thanks to the option, we can display a text without concerning about breaking lines. For general cases of text, even the option works within very short time, almost 1 tick. How does it possible ? What is the implementation of that option ? Let us find out it in this post.</p>
<img src="/2022/03/22/how-the-text-wrap-works-in-unrealengine/02.png" class="">
<img src="/2022/03/22/how-the-text-wrap-works-in-unrealengine/03.png" class="">

<p>The TextBlock upper has the option turned on. Contrary, the TextBlock lower has the option turned off.</p>
<h1 id="Where-is-the-code"><a href="#Where-is-the-code" class="headerlink" title="Where is the code"></a><em><code>Where is the code</code></em></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TextWidgetTypes.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** True if we&#x27;re wrapping text automatically based on the computed horizontal space for this widget. */</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category=Wrapping)</span><br><span class="line">uint8 AutoWrapText:<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>The option is loacted in the class <code>UTextLayoutWidget</code>. We can see the option as the class <code>UTextBlock</code> inherites <code>UTextLayoutWidget</code>. Unfortunately, the variable is not directly used for wrapping text, but used for saving the value of option.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UTextBlock::SynchronizeProperties</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">SynchronizeProperties</span>();</span><br><span class="line"></span><br><span class="line">	TAttribute&lt;FText&gt; TextBinding = <span class="built_in">GetDisplayText</span>();</span><br><span class="line">	TAttribute&lt;FSlateColor&gt; ColorAndOpacityBinding = <span class="built_in">PROPERTY_BINDING</span>(FSlateColor, ColorAndOpacity);</span><br><span class="line">	TAttribute&lt;FLinearColor&gt; ShadowColorAndOpacityBinding = <span class="built_in">PROPERTY_BINDING</span>(FLinearColor, ShadowColorAndOpacity);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( MyTextBlock.<span class="built_in">IsValid</span>() )</span><br><span class="line">	&#123;</span><br><span class="line">		MyTextBlock-&gt;<span class="built_in">SetText</span>( TextBinding );</span><br><span class="line">		MyTextBlock-&gt;<span class="built_in">SetFont</span>( Font );</span><br><span class="line">		MyTextBlock-&gt;<span class="built_in">SetStrikeBrush</span>( &amp;StrikeBrush );</span><br><span class="line">		MyTextBlock-&gt;<span class="built_in">SetColorAndOpacity</span>( ColorAndOpacityBinding );</span><br><span class="line">		MyTextBlock-&gt;<span class="built_in">SetShadowOffset</span>( ShadowOffset );</span><br><span class="line">		MyTextBlock-&gt;<span class="built_in">SetShadowColorAndOpacity</span>( ShadowColorAndOpacityBinding );</span><br><span class="line">		MyTextBlock-&gt;<span class="built_in">SetMinDesiredWidth</span>( MinDesiredWidth );</span><br><span class="line">		MyTextBlock-&gt;<span class="built_in">SetTransformPolicy</span>( TextTransformPolicy );</span><br><span class="line">		MyTextBlock-&gt;<span class="built_in">SetOverflowPolicy</span>(TextOverflowPolicy);</span><br><span class="line"></span><br><span class="line">		Super::<span class="built_in">SynchronizeTextLayoutProperties</span>( *MyTextBlock );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When you turn on or turn off the option <code>AutoWrapText</code>, widget’s <code>SynchronizeProperties()</code> would be called. By the code <code>Super::SynchronizeTextLayoutProperties(*MyTextBlock);</code> executed, Parent’s <code>SynchronizeProperties(TWidgetType&amp;)</code> is called.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Synchronize the properties with the given widget. A template as the Slate widgets conform to the same API, but don&#x27;t derive from a common base. */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TWidgetType&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SynchronizeTextLayoutProperties</span><span class="params">(TWidgetType&amp; InWidget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ShapedTextOptions.<span class="built_in">SynchronizeShapedTextProperties</span>(InWidget);</span><br><span class="line"></span><br><span class="line">    InWidget.<span class="built_in">SetJustification</span>(Justification);</span><br><span class="line">    InWidget.<span class="built_in">SetAutoWrapText</span>(!!AutoWrapText);</span><br><span class="line">    InWidget.<span class="built_in">SetWrapTextAt</span>(WrapTextAt != <span class="number">0</span> ? WrapTextAt : <span class="built_in">TAttribute</span>&lt;<span class="type">float</span>&gt;());</span><br><span class="line">    InWidget.<span class="built_in">SetWrappingPolicy</span>(WrappingPolicy);</span><br><span class="line">    InWidget.<span class="built_in">SetMargin</span>(Margin);</span><br><span class="line">    InWidget.<span class="built_in">SetLineHeightPercentage</span>(LineHeightPercentage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In this function, <code>InWidget</code> is our TextBlock. And it would call the function <code>SetAutoWrapText(bool)</code> for updating the option.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UTextBlock::SetAutoWrapText</span><span class="params">(<span class="type">bool</span> InAutoWrapText)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AutoWrapText = InAutoWrapText;</span><br><span class="line">	<span class="keyword">if</span>(MyTextBlock.<span class="built_in">IsValid</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		MyTextBlock-&gt;<span class="built_in">SetAutoWrapText</span>(InAutoWrapText);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Good. The parameter <code>InAutoWrapText</code> updates the variable <code>AutoWrapText</code> and <code>MyTextBlock</code>. The variable <code>MyTextBlock</code> is <code>TSharedPtr&lt;STextBlock&gt;</code>. Now, the time to jump to <code>STextBlock</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">STextBlock::SetAutoWrapText</span><span class="params">(TAttribute&lt;<span class="type">bool</span>&gt; InAutoWrapText)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AutoWrapText.<span class="built_in">Assign</span>(*<span class="keyword">this</span>, <span class="built_in">MoveTemp</span>(InAutoWrapText), <span class="number">0.f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Here, in <code>STextBlock</code> the variable <code>AutoWrapText</code> holds the value of option. The function <code>Assign()</code> just saves the value its inside. The value of <code>AutoWrapText</code> is used in two positions.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// STextBlock.cpp</span></span><br><span class="line"><span class="function">FVector2D <span class="title">STextBlock::ComputeDesiredSize</span><span class="params">(<span class="type">float</span> LayoutScaleMultiplier)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">SCOPE_CYCLE_COUNTER</span>(Stat_SlateTextBlockCDS);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bSimpleTextMode)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> FVector2D LocalShadowOffset = <span class="built_in">GetShadowOffset</span>();</span><br><span class="line"></span><br><span class="line">		<span class="type">const</span> <span class="type">float</span> LocalOutlineSize = (<span class="type">float</span>)(<span class="built_in">GetFont</span>().OutlineSettings.OutlineSize);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Account for the outline width impacting both size of the text by multiplying by 2</span></span><br><span class="line">		<span class="comment">// Outline size in Y is accounted for in MaxHeight calculation in Measure()</span></span><br><span class="line">		<span class="function"><span class="type">const</span> FVector2D <span class="title">ComputedOutlineSize</span><span class="params">(LocalOutlineSize * <span class="number">2.f</span>, LocalOutlineSize)</span></span>;</span><br><span class="line">		<span class="type">const</span> FVector2D TextSize = FSlateApplication::<span class="built_in">Get</span>().<span class="built_in">GetRenderer</span>()-&gt;<span class="built_in">GetFontMeasureService</span>()-&gt;<span class="built_in">Measure</span>(BoundText.<span class="built_in">Get</span>(), <span class="built_in">GetFont</span>()) + ComputedOutlineSize + LocalShadowOffset;</span><br><span class="line"></span><br><span class="line">		CachedSimpleDesiredSize = <span class="built_in">FVector2f</span>(FMath::<span class="built_in">Max</span>(MinDesiredWidth.<span class="built_in">Get</span>(), TextSize.X), TextSize.Y);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">FVector2D</span>(CachedSimpleDesiredSize.<span class="built_in">GetValue</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// ComputeDesiredSize will also update the text layout cache if required</span></span><br><span class="line">		<span class="type">const</span> FVector2D TextSize = TextLayoutCache-&gt;<span class="built_in">ComputeDesiredSize</span>(</span><br><span class="line">			FSlateTextBlockLayout::<span class="built_in">FWidgetDesiredSizeArgs</span>(</span><br><span class="line">				BoundText.<span class="built_in">Get</span>(),</span><br><span class="line">				HighlightText.<span class="built_in">Get</span>(),</span><br><span class="line">				WrapTextAt.<span class="built_in">Get</span>(),</span><br><span class="line">				AutoWrapText.<span class="built_in">Get</span>(),</span><br><span class="line">				WrappingPolicy.<span class="built_in">Get</span>(),</span><br><span class="line">				<span class="built_in">GetTransformPolicyImpl</span>(),</span><br><span class="line">				Margin.<span class="built_in">Get</span>(),</span><br><span class="line">				LineHeightPercentage.<span class="built_in">Get</span>(),</span><br><span class="line">				Justification.<span class="built_in">Get</span>()),</span><br><span class="line">			LayoutScaleMultiplier, <span class="built_in">GetComputedTextStyle</span>());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">FVector2D</span>(FMath::<span class="built_in">Max</span>(MinDesiredWidth.<span class="built_in">Get</span>(), TextSize.X), TextSize.Y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Callstack</span></span><br><span class="line">UnrealEditor-Slate.dll!STextBlock::<span class="built_in">ComputeDesiredSize</span>(<span class="type">float</span> LayoutScaleMultiplier) Line <span class="number">300</span>	C++</span><br><span class="line">UnrealEditor-SlateCore.dll!SWidget::<span class="built_in">CacheDesiredSize</span>(<span class="type">float</span> InLayoutScaleMultiplier) Line <span class="number">936</span>	C++</span><br><span class="line">UnrealEditor-SlateCore.dll!SWidget::<span class="built_in">Prepass_Internal</span>(<span class="type">float</span> InLayoutScaleMultiplier) Line <span class="number">1714</span>	C++</span><br><span class="line">[Inline Frame] UnrealEditor-SlateCore.dll!SWidget::Prepass_ChildLoop::__l2::&lt;lambda_a0677895c4614612fd5b4c5f4771eae9&gt;::<span class="built_in">operator</span>()(SWidget &amp;) Line <span class="number">1751</span>	C++</span><br><span class="line">UnrealEditor-SlateCore.dll!FChildren::ForEachWidget&lt;&lt;lambda_a0677895c4614612fd5b4c5f4771eae9&gt;&gt;(SWidget::Prepass_ChildLoop::__l2::&lt;lambda_a0677895c4614612fd5b4c5f4771eae9&gt; Pred) Line <span class="number">67</span>	C++</span><br><span class="line">[Inline Frame] UnrealEditor-SlateCore.dll!SWidget::<span class="built_in">Prepass_ChildLoop</span>(<span class="type">float</span>) Line <span class="number">1721</span>	C++</span><br><span class="line">UnrealEditor-SlateCore.dll!SWidget::<span class="built_in">Prepass_Internal</span>(<span class="type">float</span> InLayoutScaleMultiplier) Line <span class="number">1708</span>	C++</span><br><span class="line">...</span><br><span class="line">UnrealEditor-SlateCore.dll!SWidget::<span class="built_in">Prepass_Internal</span>(<span class="type">float</span> InLayoutScaleMultiplier) Line <span class="number">1708</span>	C++</span><br><span class="line">[Inline Frame] UnrealEditor-SlateCore.dll!SWidget::Prepass_ChildLoop::__l2::&lt;lambda_a0677895c4614612fd5b4c5f4771eae9&gt;::<span class="built_in">operator</span>()(SWidget &amp;) Line <span class="number">1751</span>	C++</span><br><span class="line">UnrealEditor-SlateCore.dll!FChildren::ForEachWidget&lt;&lt;lambda_a0677895c4614612fd5b4c5f4771eae9&gt;&gt;(SWidget::Prepass_ChildLoop::__l2::&lt;lambda_a0677895c4614612fd5b4c5f4771eae9&gt; Pred) Line <span class="number">67</span>	C++</span><br><span class="line">[Inline Frame] UnrealEditor-SlateCore.dll!SWidget::<span class="built_in">Prepass_ChildLoop</span>(<span class="type">float</span>) Line <span class="number">1721</span>	C++</span><br><span class="line">UnrealEditor-SlateCore.dll!SWidget::<span class="built_in">Prepass_Internal</span>(<span class="type">float</span> InLayoutScaleMultiplier) Line <span class="number">1708</span>	C++</span><br><span class="line">UnrealEditor-SlateCore.dll!SWidget::<span class="built_in">SlatePrepass</span>(<span class="type">float</span> InLayoutScaleMultiplier) Line <span class="number">690</span>	C++</span><br><span class="line">UnrealEditor-Slate.dll!<span class="built_in">PrepassWindowAndChildren</span>(TSharedRef&lt;SWindow,<span class="number">1</span>&gt; WindowToPrepass) Line <span class="number">1197</span>	C++</span><br><span class="line">UnrealEditor-Slate.dll!FSlateApplication::<span class="built_in">DrawPrepass</span>(TSharedPtr&lt;SWindow,<span class="number">1</span>&gt; DrawOnlyThisWindow) Line <span class="number">1249</span>	C++</span><br><span class="line">UnrealEditor-Slate.dll!FSlateApplication::<span class="built_in">PrivateDrawWindows</span>(TSharedPtr&lt;SWindow,<span class="number">1</span>&gt; DrawOnlyThisWindow) Line <span class="number">1294</span>	C++</span><br><span class="line">UnrealEditor-Slate.dll!FSlateApplication::<span class="built_in">DrawWindows</span>() Line <span class="number">1060</span>	C++</span><br><span class="line">UnrealEditor-Slate.dll!FSlateApplication::<span class="built_in">TickAndDrawWidgets</span>(<span class="type">float</span> DeltaTime) Line <span class="number">1625</span>	C++</span><br><span class="line">UnrealEditor-Slate.dll!FSlateApplication::<span class="built_in">Tick</span>(ESlateTickType TickType) Line <span class="number">1482</span>	C++</span><br><span class="line">UnrealEditor.exe!FEngineLoop::<span class="built_in">Tick</span>() Line <span class="number">5325</span>	C++</span><br><span class="line">[Inline Frame] UnrealEditor.exe!<span class="built_in">EngineTick</span>() Line <span class="number">62</span>	C++</span><br><span class="line">UnrealEditor.exe!<span class="built_in">GuardedMain</span>(<span class="type">const</span> <span class="type">wchar_t</span> * CmdLine) Line <span class="number">183</span>	C++</span><br><span class="line">UnrealEditor.exe!<span class="built_in">GuardedMainWrapper</span>(<span class="type">const</span> <span class="type">wchar_t</span> * CmdLine) Line <span class="number">147</span>	C++</span><br><span class="line">UnrealEditor.exe!<span class="built_in">LaunchWindowsStartup</span>(HINSTANCE__ * hInInstance, HINSTANCE__ * hPrevInstance, <span class="type">char</span> * __formal, <span class="type">int</span> nCmdShow, <span class="type">const</span> <span class="type">wchar_t</span> * CmdLine) Line <span class="number">283</span>	C++</span><br><span class="line">UnrealEditor.exe!<span class="built_in">WinMain</span>(HINSTANCE__ * hInInstance, HINSTANCE__ * hPrevInstance, <span class="type">char</span> * pCmdLine, <span class="type">int</span> nCmdShow) Line <span class="number">330</span>	C++</span><br><span class="line">[External Code]</span><br></pre></td></tr></table></figure>

<p>First, an execution flow by Prepass.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// STextBlock.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">int32 <span class="title">STextBlock::OnPaint</span><span class="params">( <span class="type">const</span> FPaintArgs&amp; Args, <span class="type">const</span> FGeometry&amp; AllottedGeometry, <span class="type">const</span> FSlateRect&amp; MyCullingRect, FSlateWindowElementList&amp; OutDrawElements, int32 LayerId, <span class="type">const</span> FWidgetStyle&amp; InWidgetStyle, <span class="type">bool</span> bParentEnabled )</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">SCOPE_CYCLE_COUNTER</span>(Stat_SlateTextBlockOnPaint);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bSimpleTextMode)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Draw the optional shadow</span></span><br><span class="line">		<span class="type">const</span> FLinearColor LocalShadowColorAndOpacity = <span class="built_in">GetShadowColorAndOpacity</span>();</span><br><span class="line">		<span class="type">const</span> FVector2D LocalShadowOffset = <span class="built_in">GetShadowOffset</span>();</span><br><span class="line">		<span class="type">const</span> <span class="type">bool</span> ShouldDropShadow = LocalShadowColorAndOpacity.A &gt; <span class="number">0.f</span> &amp;&amp; LocalShadowOffset.<span class="built_in">SizeSquared</span>() &gt; <span class="number">0.f</span>;</span><br><span class="line"></span><br><span class="line">		<span class="type">const</span> <span class="type">bool</span> bShouldBeEnabled = <span class="built_in">ShouldBeEnabled</span>(bParentEnabled);</span><br><span class="line"></span><br><span class="line">		<span class="type">const</span> FText&amp; LocalText = BoundText.<span class="built_in">Get</span>();</span><br><span class="line">		FSlateFontInfo LocalFont = <span class="built_in">GetFont</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ShouldDropShadow)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">const</span> int32 OutlineSize = LocalFont.OutlineSettings.OutlineSize;</span><br><span class="line">			<span class="keyword">if</span> (!LocalFont.OutlineSettings.bApplyOutlineToDropShadows)</span><br><span class="line">			&#123;</span><br><span class="line">				LocalFont.OutlineSettings.OutlineSize = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			FSlateDrawElement::<span class="built_in">MakeText</span>(</span><br><span class="line">				OutDrawElements,</span><br><span class="line">				LayerId,</span><br><span class="line">				AllottedGeometry.<span class="built_in">ToOffsetPaintGeometry</span>(LocalShadowOffset),</span><br><span class="line">				LocalText,</span><br><span class="line">				LocalFont,</span><br><span class="line">				bShouldBeEnabled ? ESlateDrawEffect::None : ESlateDrawEffect::DisabledEffect,</span><br><span class="line">				InWidgetStyle.<span class="built_in">GetColorAndOpacityTint</span>() * LocalShadowColorAndOpacity</span><br><span class="line">			);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Restore outline size for main text</span></span><br><span class="line">			LocalFont.OutlineSettings.OutlineSize = OutlineSize;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// actual text should appear above the shadow</span></span><br><span class="line">			++LayerId;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Draw the text itself</span></span><br><span class="line">		FSlateDrawElement::<span class="built_in">MakeText</span>(</span><br><span class="line">			OutDrawElements,</span><br><span class="line">			LayerId,</span><br><span class="line">			AllottedGeometry.<span class="built_in">ToPaintGeometry</span>(),</span><br><span class="line">			LocalText,</span><br><span class="line">			LocalFont,</span><br><span class="line">			bShouldBeEnabled ? ESlateDrawEffect::None : ESlateDrawEffect::DisabledEffect,</span><br><span class="line">			InWidgetStyle.<span class="built_in">GetColorAndOpacityTint</span>() * <span class="built_in">GetColorAndOpacity</span>().<span class="built_in">GetColor</span>(InWidgetStyle)</span><br><span class="line">			);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> FVector2D LastDesiredSize = TextLayoutCache-&gt;<span class="built_in">GetDesiredSize</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// OnPaint will also update the text layout cache if required</span></span><br><span class="line">		LayerId = TextLayoutCache-&gt;<span class="built_in">OnPaint</span>(Args, AllottedGeometry, MyCullingRect, OutDrawElements, LayerId, InWidgetStyle, <span class="built_in">ShouldBeEnabled</span>(bParentEnabled));</span><br><span class="line"></span><br><span class="line">		<span class="type">const</span> FVector2D NewDesiredSize = TextLayoutCache-&gt;<span class="built_in">GetDesiredSize</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// <span class="doctag">HACK:</span> Due to the nature of wrapping and layout, we may have been arranged in a different box than what we were cached with.  Which</span></span><br><span class="line">		<span class="comment">// might update wrapping, so make sure we always set the desired size to the current size of the text layout, which may have changed</span></span><br><span class="line">		<span class="comment">// during paint.</span></span><br><span class="line">		<span class="type">const</span> <span class="type">bool</span> bCanWrap = WrapTextAt.<span class="built_in">Get</span>() &gt; <span class="number">0</span> || AutoWrapText.<span class="built_in">Get</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (bCanWrap &amp;&amp; !NewDesiredSize.<span class="built_in">Equals</span>(LastDesiredSize))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">const_cast</span>&lt;STextBlock*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">Invalidate</span>(EInvalidateWidgetReason::Layout);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> LayerId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Callstack</span></span><br><span class="line">UnrealEditor-Slate.dll!STextBlock::<span class="built_in">OnPaint</span>(<span class="type">const</span> FPaintArgs &amp; Args, <span class="type">const</span> FGeometry &amp; AllottedGeometry, <span class="type">const</span> FSlateRect &amp; MyCullingRect, FSlateWindowElementList &amp; OutDrawElements, <span class="type">int</span> LayerId, <span class="type">const</span> FWidgetStyle &amp; InWidgetStyle, <span class="type">bool</span> bParentEnabled) Line <span class="number">255</span>	C++</span><br><span class="line">UnrealEditor-SlateCore.dll!SWidget::<span class="built_in">Paint</span>(<span class="type">const</span> FPaintArgs &amp; Args, <span class="type">const</span> FGeometry &amp; AllottedGeometry, <span class="type">const</span> FSlateRect &amp; MyCullingRect, FSlateWindowElementList &amp; OutDrawElements, <span class="type">int</span> LayerId, <span class="type">const</span> FWidgetStyle &amp; InWidgetStyle, <span class="type">bool</span> bParentEnabled) Line <span class="number">1543</span>	C++</span><br><span class="line">UnrealEditor-SlateCore.dll!SPanel::<span class="built_in">PaintArrangedChildren</span>(<span class="type">const</span> FPaintArgs &amp; Args, <span class="type">const</span> FArrangedChildren &amp; ArrangedChildren, <span class="type">const</span> FGeometry &amp; AllottedGeometry, <span class="type">const</span> FSlateRect &amp; MyCullingRect, FSlateWindowElementList &amp; OutDrawElements, <span class="type">int</span> LayerId, <span class="type">const</span> FWidgetStyle &amp; InWidgetStyle, <span class="type">bool</span> bParentEnabled) Line <span class="number">31</span>	C++</span><br><span class="line">UnrealEditor-SlateCore.dll!SPanel::<span class="built_in">OnPaint</span>(<span class="type">const</span> FPaintArgs &amp; Args, <span class="type">const</span> FGeometry &amp; AllottedGeometry, <span class="type">const</span> FSlateRect &amp; MyCullingRect, FSlateWindowElementList &amp; OutDrawElements, <span class="type">int</span> LayerId, <span class="type">const</span> FWidgetStyle &amp; InWidgetStyle, <span class="type">bool</span> bParentEnabled) Line <span class="number">12</span>	C++</span><br><span class="line">UnrealEditor-SlateCore.dll!SWidget::<span class="built_in">Paint</span>(<span class="type">const</span> FPaintArgs &amp; Args, <span class="type">const</span> FGeometry &amp; AllottedGeometry, <span class="type">const</span> FSlateRect &amp; MyCullingRect, FSlateWindowElementList &amp; OutDrawElements, <span class="type">int</span> LayerId, <span class="type">const</span> FWidgetStyle &amp; InWidgetStyle, <span class="type">bool</span> bParentEnabled) Line <span class="number">1543</span>	C++</span><br><span class="line">...</span><br><span class="line">UnrealEditor-SlateCore.dll!SPanel::<span class="built_in">PaintArrangedChildren</span>(<span class="type">const</span> FPaintArgs &amp; Args, <span class="type">const</span> FArrangedChildren &amp; ArrangedChildren, <span class="type">const</span> FGeometry &amp; AllottedGeometry, <span class="type">const</span> FSlateRect &amp; MyCullingRect, FSlateWindowElementList &amp; OutDrawElements, <span class="type">int</span> LayerId, <span class="type">const</span> FWidgetStyle &amp; InWidgetStyle, <span class="type">bool</span> bParentEnabled) Line <span class="number">31</span>	C++</span><br><span class="line">UnrealEditor-SlateCore.dll!SPanel::<span class="built_in">OnPaint</span>(<span class="type">const</span> FPaintArgs &amp; Args, <span class="type">const</span> FGeometry &amp; AllottedGeometry, <span class="type">const</span> FSlateRect &amp; MyCullingRect, FSlateWindowElementList &amp; OutDrawElements, <span class="type">int</span> LayerId, <span class="type">const</span> FWidgetStyle &amp; InWidgetStyle, <span class="type">bool</span> bParentEnabled) Line <span class="number">12</span>	C++</span><br><span class="line">UnrealEditor-SlateCore.dll!SWidget::<span class="built_in">Paint</span>(<span class="type">const</span> FPaintArgs &amp; Args, <span class="type">const</span> FGeometry &amp; AllottedGeometry, <span class="type">const</span> FSlateRect &amp; MyCullingRect, FSlateWindowElementList &amp; OutDrawElements, <span class="type">int</span> LayerId, <span class="type">const</span> FWidgetStyle &amp; InWidgetStyle, <span class="type">bool</span> bParentEnabled) Line <span class="number">1543</span>	C++</span><br><span class="line">UnrealEditor-SlateCore.dll!SOverlay::<span class="built_in">OnPaint</span>(<span class="type">const</span> FPaintArgs &amp; Args, <span class="type">const</span> FGeometry &amp; AllottedGeometry, <span class="type">const</span> FSlateRect &amp; MyCullingRect, FSlateWindowElementList &amp; OutDrawElements, <span class="type">int</span> LayerId, <span class="type">const</span> FWidgetStyle &amp; InWidgetStyle, <span class="type">bool</span> bParentEnabled) Line <span class="number">200</span>	C++</span><br><span class="line">UnrealEditor-SlateCore.dll!SWidget::<span class="built_in">Paint</span>(<span class="type">const</span> FPaintArgs &amp; Args, <span class="type">const</span> FGeometry &amp; AllottedGeometry, <span class="type">const</span> FSlateRect &amp; MyCullingRect, FSlateWindowElementList &amp; OutDrawElements, <span class="type">int</span> LayerId, <span class="type">const</span> FWidgetStyle &amp; InWidgetStyle, <span class="type">bool</span> bParentEnabled) Line <span class="number">1543</span>	C++</span><br><span class="line">UnrealEditor-SlateCore.dll!SCompoundWidget::<span class="built_in">OnPaint</span>(<span class="type">const</span> FPaintArgs &amp; Args, <span class="type">const</span> FGeometry &amp; AllottedGeometry, <span class="type">const</span> FSlateRect &amp; MyCullingRect, FSlateWindowElementList &amp; OutDrawElements, <span class="type">int</span> LayerId, <span class="type">const</span> FWidgetStyle &amp; InWidgetStyle, <span class="type">bool</span> bParentEnabled) Line <span class="number">46</span>	C++</span><br><span class="line">UnrealEditor-SlateCore.dll!SWidget::<span class="built_in">Paint</span>(<span class="type">const</span> FPaintArgs &amp; Args, <span class="type">const</span> FGeometry &amp; AllottedGeometry, <span class="type">const</span> FSlateRect &amp; MyCullingRect, FSlateWindowElementList &amp; OutDrawElements, <span class="type">int</span> LayerId, <span class="type">const</span> FWidgetStyle &amp; InWidgetStyle, <span class="type">bool</span> bParentEnabled) Line <span class="number">1543</span>	C++</span><br><span class="line">UnrealEditor-SlateCore.dll!SWindow::<span class="built_in">PaintSlowPath</span>(<span class="type">const</span> FSlateInvalidationContext &amp; Context) Line <span class="number">2073</span>	C++</span><br><span class="line">UnrealEditor-SlateCore.dll!FSlateInvalidationRoot::<span class="built_in">PaintInvalidationRoot</span>(<span class="type">const</span> FSlateInvalidationContext &amp; Context) Line <span class="number">399</span>	C++</span><br><span class="line">UnrealEditor-SlateCore.dll!SWindow::<span class="built_in">PaintWindow</span>(<span class="type">double</span> CurrentTime, <span class="type">float</span> DeltaTime, FSlateWindowElementList &amp; OutDrawElements, <span class="type">const</span> FWidgetStyle &amp; InWidgetStyle, <span class="type">bool</span> bParentEnabled) Line <span class="number">2105</span>	C++</span><br><span class="line">UnrealEditor-Slate.dll!FSlateApplication::<span class="built_in">DrawWindowAndChildren</span>(<span class="type">const</span> TSharedRef&lt;SWindow,<span class="number">1</span>&gt; &amp; WindowToDraw, FDrawWindowArgs &amp; DrawWindowArgs) Line <span class="number">1106</span>	C++</span><br><span class="line">UnrealEditor-Slate.dll!FSlateApplication::<span class="built_in">PrivateDrawWindows</span>(TSharedPtr&lt;SWindow,<span class="number">1</span>&gt; DrawOnlyThisWindow) Line <span class="number">1338</span>	C++</span><br><span class="line">UnrealEditor-Slate.dll!FSlateApplication::<span class="built_in">DrawWindows</span>() Line <span class="number">1060</span>	C++</span><br><span class="line">UnrealEditor-Slate.dll!FSlateApplication::<span class="built_in">TickAndDrawWidgets</span>(<span class="type">float</span> DeltaTime) Line <span class="number">1625</span>	C++</span><br><span class="line">UnrealEditor-Slate.dll!FSlateApplication::<span class="built_in">Tick</span>(ESlateTickType TickType) Line <span class="number">1482</span>	C++</span><br><span class="line">UnrealEditor.exe!FEngineLoop::<span class="built_in">Tick</span>() Line <span class="number">5325</span>	C++</span><br><span class="line">[Inline Frame] UnrealEditor.exe!<span class="built_in">EngineTick</span>() Line <span class="number">62</span>	C++</span><br><span class="line">UnrealEditor.exe!<span class="built_in">GuardedMain</span>(<span class="type">const</span> <span class="type">wchar_t</span> * CmdLine) Line <span class="number">183</span>	C++</span><br><span class="line">UnrealEditor.exe!<span class="built_in">GuardedMainWrapper</span>(<span class="type">const</span> <span class="type">wchar_t</span> * CmdLine) Line <span class="number">147</span>	C++</span><br><span class="line">UnrealEditor.exe!<span class="built_in">LaunchWindowsStartup</span>(HINSTANCE__ * hInInstance, HINSTANCE__ * hPrevInstance, <span class="type">char</span> * __formal, <span class="type">int</span> nCmdShow, <span class="type">const</span> <span class="type">wchar_t</span> * CmdLine) Line <span class="number">283</span>	C++</span><br><span class="line">UnrealEditor.exe!<span class="built_in">WinMain</span>(HINSTANCE__ * hInInstance, HINSTANCE__ * hPrevInstance, <span class="type">char</span> * pCmdLine, <span class="type">int</span> nCmdShow) Line <span class="number">330</span>	C++</span><br><span class="line">[External Code]	</span><br></pre></td></tr></table></figure>

<p>Second, an execution flow by Paint.</p>
<p>The flows are branched at <code>FSlateApplication::PrivateDrawWindows()</code>. In the function, <code>DrawPrepass()</code> is called at line #1292, and <code>DrawWindowAndChildren()</code> is called at line #1338. Respectively, Prepass and Paint. Engine just invalidate the widget in Paint flow, so we only need to look into Prepass flow.</p>
<h1 id="Calculating-a-length-of-text-wrap"><a href="#Calculating-a-length-of-text-wrap" class="headerlink" title="Calculating a length of text wrap"></a><em><code>Calculating a length of text wrap</code></em></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FVector2D <span class="title">FSlateTextBlockLayout::ComputeDesiredSize</span><span class="params">(<span class="type">const</span> FWidgetDesiredSizeArgs&amp; InWidgetArgs, <span class="type">const</span> <span class="type">float</span> InScale, <span class="type">const</span> FTextBlockStyle&amp; InTextStyle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Cache the wrapping rules so that we can recompute the wrap at width in paint.</span></span><br><span class="line">	CachedWrapTextAt = InWidgetArgs.WrapTextAt;</span><br><span class="line">	bCachedAutoWrapText = InWidgetArgs.AutoWrapText;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> ETextTransformPolicy PreviousTransformPolicy = TextLayout-&gt;<span class="built_in">GetTransformPolicy</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set the text layout information</span></span><br><span class="line">	TextLayout-&gt;<span class="built_in">SetScale</span>(InScale);</span><br><span class="line">	TextLayout-&gt;<span class="built_in">SetWrappingWidth</span>(<span class="built_in">CalculateWrappingWidth</span>());</span><br><span class="line">	TextLayout-&gt;<span class="built_in">SetWrappingPolicy</span>(InWidgetArgs.WrappingPolicy);</span><br><span class="line">	TextLayout-&gt;<span class="built_in">SetTransformPolicy</span>(InWidgetArgs.TransformPolicy);</span><br><span class="line">	TextLayout-&gt;<span class="built_in">SetMargin</span>(InWidgetArgs.Margin);</span><br><span class="line">	TextLayout-&gt;<span class="built_in">SetJustification</span>(InWidgetArgs.Justification);</span><br><span class="line">	TextLayout-&gt;<span class="built_in">SetLineHeightPercentage</span>(InWidgetArgs.LineHeightPercentage);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Has the transform policy changed? If so we need a full refresh as that is destructive to the model text</span></span><br><span class="line">	<span class="keyword">if</span> (PreviousTransformPolicy != TextLayout-&gt;<span class="built_in">GetTransformPolicy</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		Marshaller-&gt;<span class="built_in">MakeDirty</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Has the style used for this text block changed?</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">IsStyleUpToDate</span>(InTextStyle))</span><br><span class="line">	&#123;</span><br><span class="line">		TextLayout-&gt;<span class="built_in">SetDefaultTextStyle</span>(InTextStyle);</span><br><span class="line">		Marshaller-&gt;<span class="built_in">MakeDirty</span>(); <span class="comment">// will regenerate the text using the new default style</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">bool</span> bRequiresTextUpdate = <span class="literal">false</span>;</span><br><span class="line">		<span class="type">const</span> FText&amp; TextToSet = InWidgetArgs.Text;</span><br><span class="line">		<span class="keyword">if</span> (!TextLastUpdate.<span class="built_in">IdenticalTo</span>(TextToSet))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// The pointer used by the bound text has changed, however the text may still be the same - check that now</span></span><br><span class="line">			<span class="keyword">if</span> (!TextLastUpdate.<span class="built_in">IsDisplayStringEqualTo</span>(TextToSet))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// The source text has changed, so update the internal text</span></span><br><span class="line">				bRequiresTextUpdate = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Update this even if the text is lexically identical, as it will update the pointer compared by IdenticalTo for the next Tick</span></span><br><span class="line">			TextLastUpdate = <span class="built_in">FTextSnapshot</span>(TextToSet);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (bRequiresTextUpdate || Marshaller-&gt;<span class="built_in">IsDirty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">UpdateTextLayout</span>(TextToSet);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> FText&amp; HighlightTextToSet = InWidgetArgs.HighlightText;</span><br><span class="line">		<span class="keyword">if</span> (!HighlightTextLastUpdate.<span class="built_in">IdenticalTo</span>(HighlightTextToSet))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// The pointer used by the bound text has changed, however the text may still be the same - check that now</span></span><br><span class="line">			<span class="keyword">if</span> (!HighlightTextLastUpdate.<span class="built_in">IsDisplayStringEqualTo</span>(HighlightTextToSet))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">UpdateTextHighlights</span>(HighlightTextToSet);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Update this even if the text is lexically identical, as it will update the pointer compared by IdenticalTo for the next Tick</span></span><br><span class="line">			HighlightTextLastUpdate = <span class="built_in">FTextSnapshot</span>(HighlightTextToSet);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We need to update our size if the text layout has become dirty</span></span><br><span class="line">	TextLayout-&gt;<span class="built_in">UpdateIfNeeded</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TextLayout-&gt;<span class="built_in">GetSize</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The function <code>FSlateTextBlockLayout::ComputeDesiredSize()</code> is called during Prepass flow. Here, <code>bCachedAutoWrapText</code> caches the value of <code>InWidgetArgs.AutoWrapText</code>. This will be used at <code>CalculateWrappingWidth()</code> later.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">FSlateTextBlockLayout::CalculateWrappingWidth</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Text wrapping can either be used defined (WrapTextAt), automatic (bAutoWrapText and CachedSize), </span></span><br><span class="line">	<span class="comment">// or a mixture of both. Take whichever has the smallest value (&gt;1)</span></span><br><span class="line">	<span class="type">float</span> WrappingWidth = CachedWrapTextAt;</span><br><span class="line">	<span class="keyword">if</span> (bCachedAutoWrapText &amp;&amp; CachedSize.X &gt;= <span class="number">1.0f</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		WrappingWidth = (WrappingWidth &gt;= <span class="number">1.0f</span>) ? FMath::<span class="built_in">Min</span>(WrappingWidth, CachedSize.X) : CachedSize.X;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> FMath::<span class="built_in">Max</span>(<span class="number">0.0f</span>, WrappingWidth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <code>CachedWrapTextAt</code> will be the same with the value set by option <code>WrapTextAt</code> in editor. And, the <code>CachedSize</code> depends on the size of panel where the TextBlock resides in. In the example we are using, the variables would have a value like below:</p>
<ul>
<li><code>CachedWrapTextAt</code> &#x3D; 0</li>
<li><code>CachedSize.X</code> &#x3D; 100</li>
</ul>
<p>Because the width of SizeBox is 100 and we set the option <code>WrapTextAt</code> as 0. The function determines the length of wrapping, but it is not for the logic about how to divide texts or how to break lines. So, look back on <code>FSlateTextBlockLayout::ComputeDesiredSize()</code>.</p>
<h1 id="UpdateLayout-when-it-is-dirty"><a href="#UpdateLayout-when-it-is-dirty" class="headerlink" title="UpdateLayout when it is dirty"></a><em><code>UpdateLayout when it is dirty</code></em></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SlateTextBlockLayout.cpp</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// We need to update our size if the text layout has become dirty</span></span><br><span class="line">TextLayout-&gt;<span class="built_in">UpdateIfNeeded</span>();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// TextLayout.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FTextLayout::UpdateIfNeeded</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (CachedLayoutGeneration != GSlateLayoutGeneration)</span><br><span class="line">	&#123;</span><br><span class="line">		CachedLayoutGeneration = GSlateLayoutGeneration;</span><br><span class="line">		DirtyFlags |= ETextLayoutDirtyState::Layout;</span><br><span class="line">		<span class="built_in">DirtyAllLineModels</span>(ELineModelDirtyState::All);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">bool</span> bHasChangedLayout = !!(DirtyFlags &amp; ETextLayoutDirtyState::Layout);</span><br><span class="line">	<span class="type">const</span> <span class="type">bool</span> bHasChangedHighlights = !!(DirtyFlags &amp; ETextLayoutDirtyState::Highlights);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( bHasChangedLayout )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// if something has changed then create a new View</span></span><br><span class="line">		<span class="built_in">UpdateLayout</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the layout has changed, we always need to update the highlights</span></span><br><span class="line">	<span class="keyword">if</span> ( bHasChangedLayout || bHasChangedHighlights)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">UpdateHighlights</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In the function, there is some code to call <code>FTextLayout::UpdateIfNeeded()</code>. Oh, the <code>UpdateLayout()</code> looks like the one we wanted. The code will be executed when <code>bHasChangedLayout</code> is true, and the value is usually set by <code>SetWrappingWidth()</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FTextLayout::SetWrappingWidth</span><span class="params">( <span class="type">float</span> Value )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">bool</span> WasWrapping = WrappingWidth &gt; <span class="number">0.0f</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">bool</span> IsWrapping = Value &gt; <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( WrappingWidth != Value )</span><br><span class="line">	&#123;</span><br><span class="line">		WrappingWidth = Value; </span><br><span class="line">		DirtyFlags |= ETextLayoutDirtyState::Layout;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ( WasWrapping != IsWrapping )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// Changing from wrapping/not-wrapping will affect the wrapping information for *all lines*</span></span><br><span class="line">			<span class="comment">// Clear out the entire cache so it gets regenerated on the text call to FlowLayout</span></span><br><span class="line">			<span class="built_in">DirtyAllLineModels</span>(ELineModelDirtyState::WrappingInformation);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Suppose you switch the option <code>AutoWrapText</code> from false into true. Here, <code>DirtyFlags</code> will flag the <code>ETextLayoutDirtyState::Layout</code>, which is 1. Therefore, <code>!!(DirtyFlags &amp; ETextLayoutDirtyState::Layout)</code> turns into 1. The <code>bHasChangedLayout</code> becomes 1, too.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FTextLayout::UpdateLayout</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">SCOPE_CYCLE_COUNTER</span>(STAT_SlateTextLayout);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ClearView</span>();</span><br><span class="line">	<span class="built_in">BeginLayout</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">FlowLayout</span>();</span><br><span class="line">	<span class="built_in">JustifyLayout</span>();</span><br><span class="line">	<span class="built_in">MarginLayout</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EndLayout</span>();</span><br><span class="line"></span><br><span class="line">	DirtyFlags &amp;= ~ETextLayoutDirtyState::Layout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <code>ClearView()</code> and <code>BeginLayout()</code> are not important in this post. Plus, they do not something important either.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FTextLayout::FlowLayout</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> WrappingDrawWidth = <span class="built_in">GetWrappingDrawWidth</span>();</span><br><span class="line"></span><br><span class="line">	TArray&lt; TSharedRef&lt; ILayoutBlock &gt; &gt; SoftLine;</span><br><span class="line">	<span class="keyword">for</span> (int32 LineModelIndex = <span class="number">0</span>; LineModelIndex &lt; LineModels.<span class="built_in">Num</span>(); LineModelIndex++)</span><br><span class="line">	&#123;</span><br><span class="line">		FLineModel&amp; LineModel = LineModels[ LineModelIndex ];</span><br><span class="line">		<span class="built_in">CalculateLineTextDirection</span>(LineModel);</span><br><span class="line">		<span class="built_in">FlushLineTextShapingCache</span>(LineModel);</span><br><span class="line">		<span class="built_in">CreateLineWrappingCache</span>(LineModel);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">FlowLineLayout</span>(LineModelIndex, WrappingDrawWidth, SoftLine);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In the <code>FlowLayout()</code>, the code that calls <code>CreateLineWrappingCache()</code> is a point since the <code>CreateLineWrappingCache()</code> creates data for wrapping text.</p>
<h1 id="Break-lines-1-3-Separating-text-into-slices"><a href="#Break-lines-1-3-Separating-text-into-slices" class="headerlink" title="Break lines (1/3); Separating text into slices"></a><em><code>Break lines (1/3); Separating text into slices</code></em></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FTextLayout::CreateLineWrappingCache</span><span class="params">(FLineModel&amp; LineModel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!(LineModel.DirtyFlags &amp; ELineModelDirtyState::WrappingInformation))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LineModel.BreakCandidates.<span class="built_in">Empty</span>();</span><br><span class="line">	LineModel.DirtyFlags &amp;= ~ELineModelDirtyState::WrappingInformation;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (int32 RunIndex = <span class="number">0</span>; RunIndex &lt; LineModel.Runs.<span class="built_in">Num</span>(); RunIndex++)</span><br><span class="line">	&#123;</span><br><span class="line">		LineModel.Runs[RunIndex].<span class="built_in">ClearCache</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">bool</span> IsWrapping = WrappingWidth &gt; <span class="number">0.0f</span>;</span><br><span class="line">	<span class="keyword">if</span> (!IsWrapping)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If we&#x27;ve not yet been provided with a custom line break iterator, then just use the default one</span></span><br><span class="line">	<span class="keyword">if</span> (!LineBreakIterator.<span class="built_in">IsValid</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		LineBreakIterator = FBreakIterator::<span class="built_in">CreateLineBreakIterator</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LineBreakIterator-&gt;<span class="built_in">SetStringRef</span>(&amp;LineModel.Text.<span class="built_in">Get</span>());</span><br><span class="line"></span><br><span class="line">	int32 PreviousBreak = <span class="number">0</span>;</span><br><span class="line">	int32 CurrentBreak = <span class="number">0</span>;</span><br><span class="line">	int32 CurrentRunIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>( ( CurrentBreak = LineBreakIterator-&gt;<span class="built_in">MoveToNext</span>() ) != INDEX_NONE )</span><br><span class="line">	&#123;</span><br><span class="line">		LineModel.BreakCandidates.<span class="built_in">Add</span>( <span class="built_in">CreateBreakCandidate</span>(<span class="comment">/*OUT*/</span>CurrentRunIndex, LineModel, PreviousBreak, CurrentBreak) );</span><br><span class="line">		PreviousBreak = CurrentBreak;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LineBreakIterator-&gt;<span class="built_in">ClearString</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In this function, we found some variables that have a name of <code>LineBreak</code>. Let us check what the line break iterator does.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TSharedRef&lt;IBreakIterator&gt; <span class="title">FBreakIterator::CreateLineBreakIterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FICULineBreakIterator</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <code>LinBreakIterator</code> is a line break iterator using the implementation of <a target="_blank" rel="noopener" href="https://github.com/unicode-org/icu/blob/main/icu4c/source/common/unicode/brkiter.h">ICU(International Components for Unicode)’s break iterator</a>. The break iterator does a job of finding a location of boundaries in text. Visit <a target="_blank" rel="noopener" href="https://unicode-org.github.io/icu-docs/apidoc/dev/icu4c/classicu_1_1BreakIterator.html#details">here</a> for more details. To summarize, the break iterator can find where each word ends. For example, we have a text of <code>Text Block Test</code> and the break iterator can find locations just like this <code>Text (HERE)Block (HERE)Test(HERE)</code>. So, let us see how it works.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">int32 <span class="title">FICULineBreakIterator::MoveToNextImpl</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TSharedRef&lt;icu::BreakIterator&gt; LineBrkIt = <span class="built_in">GetInternalLineBreakIterator</span>();</span><br><span class="line">	FICUTextCharacterIterator&amp; CharIt = <span class="built_in">static_cast</span>&lt;FICUTextCharacterIterator&amp;&gt;(LineBrkIt-&gt;<span class="built_in">getText</span>());</span><br><span class="line"></span><br><span class="line">	int32 InternalPosition = CharIt.<span class="built_in">SourceIndexToInternalIndex</span>(CurrentPosition);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// For Hangul using per-word wrapping, we walk forward to the last Hangul character in the word and use that as the starting point for the </span></span><br><span class="line">	<span class="comment">// line-break iterator, as this will correctly handle the remaining Geumchik wrapping rules, without also causing per-syllable wrapping</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">GetHangulTextWrappingMethod</span>() == EHangulTextWrappingMethod::PerWord)</span><br><span class="line">	&#123;</span><br><span class="line">		CharIt.<span class="built_in">setIndex32</span>(InternalPosition);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">IsHangul</span>(CharIt.<span class="built_in">current32</span>()))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// Walk to the end of the Hangul characters</span></span><br><span class="line">			<span class="keyword">while</span> (CharIt.<span class="built_in">hasNext</span>() &amp;&amp; <span class="built_in">IsHangul</span>(CharIt.<span class="built_in">next32</span>()))</span><br><span class="line">			&#123;</span><br><span class="line">				InternalPosition = CharIt.<span class="built_in">getIndex</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	InternalPosition = LineBrkIt-&gt;<span class="built_in">following</span>(InternalPosition);</span><br><span class="line">	CurrentPosition = CharIt.<span class="built_in">InternalIndexToSourceIndex</span>(InternalPosition);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> CurrentPosition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <code>MoveToNext()</code> calls the <code>MoveToNextImpl()</code>. And, the <code>MoveToNextImpl()</code> change the <code>InternalPosition</code>, which is used for finding a location in text.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UnrealEngine/Engine/Source/ThirdParty/ICU/icu4c-64_1/include/unicode/brkiter.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Advance the iterator to the first boundary following the specified offset.</span></span><br><span class="line"><span class="comment"> * The value returned is always greater than the offset or</span></span><br><span class="line"><span class="comment"> * the value BreakIterator.DONE</span></span><br><span class="line"><span class="comment"> * @param offset the offset to begin scanning.</span></span><br><span class="line"><span class="comment"> * @return The first boundary after the specified offset.</span></span><br><span class="line"><span class="comment"> * @stable ICU 2.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int32_t</span> <span class="title">following</span><span class="params">(<span class="type">int32_t</span> offset)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>The <code>InternalPosition</code> is passed into <code>following</code> and it is the code of ICU library.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[index] 0123456789...</span><br><span class="line">[array] Text Block Test</span><br><span class="line"></span><br><span class="line">[flow]</span><br><span class="line">PreviousBreak = 0, CurrentBreak = 0</span><br><span class="line">MoveToNext()</span><br><span class="line">PreviousBreak = 0, CurrentBreak = 5</span><br><span class="line">CreateBreakCandidate()</span><br><span class="line">PreviousBreak = 5, CurrentBreak = 5</span><br><span class="line">MoveToNext()</span><br><span class="line">PreviousBreak = 5, CurrentBreak = 11</span><br><span class="line">CreateBreakCandidate()</span><br><span class="line">PreviousBreak = 11, CurrentBreak = 11</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>In our test text, the flow looks like above.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FBreakCandidate</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/** Range inclusive of trailing whitespace, as used to visually display and interact with the text */</span></span><br><span class="line">	FTextRange ActualRange;</span><br><span class="line">	<span class="comment">/** Range exclusive of trailing whitespace, as used to perform wrapping on a word boundary */</span></span><br><span class="line">	FTextRange TrimmedRange;</span><br><span class="line">	<span class="comment">/** Measured size inclusive of trailing whitespace, as used to visually display and interact with the text */</span></span><br><span class="line">	FVector2D ActualSize;</span><br><span class="line">	<span class="comment">/** Measured width exclusive of trailing whitespace, as used to perform wrapping on a word boundary */</span></span><br><span class="line">	<span class="type">float</span> TrimmedWidth;</span><br><span class="line">	<span class="comment">/** If this break candidate has trailing whitespace, this is the width of the first character of the trailing whitespace */</span></span><br><span class="line">	<span class="type">float</span> FirstTrailingWhitespaceCharWidth;</span><br><span class="line"></span><br><span class="line">	int16 MaxAboveBaseline;</span><br><span class="line">	int16 MaxBelowBaseline;</span><br><span class="line"></span><br><span class="line">	int8 Kerning;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TEXT_LAYOUT_DEBUG</span></span><br><span class="line">	FString DebugSlice;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>A <code>FBreakCandidate</code> will be inserted into <code>BreakCandidates</code> each iteration. It seems the <code>FBreakCandidate</code> knows the size of word (or a part of text). What happened in <code>CreateBreakCandidate()</code> ? How could they know the actual size of text ?</p>
<h1 id="Break-lines-2-3-Measuring-size-of-each-slice"><a href="#Break-lines-2-3-Measuring-size-of-each-slice" class="headerlink" title="Break lines (2/3); Measuring size of each slice"></a><em><code>Break lines (2/3); Measuring size of each slice</code></em></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FTextLayout::FBreakCandidate <span class="title">FTextLayout::CreateBreakCandidate</span><span class="params">( int32&amp; OutRunIndex, FLineModel&amp; Line, int32 PreviousBreak, int32 CurrentBreak )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// We need to consider the Runs when detecting and measuring the text lengths of Lines because</span></span><br><span class="line">	<span class="comment">// the font style used makes a difference.</span></span><br><span class="line">	<span class="type">const</span> int32 FirstRunIndexChecked = OutRunIndex;</span><br><span class="line">	<span class="keyword">for</span> (; OutRunIndex &lt; Line.Runs.<span class="built_in">Num</span>(); OutRunIndex++)</span><br><span class="line">	&#123;</span><br><span class="line">		FRunModel&amp; Run = Line.Runs[ OutRunIndex ];</span><br><span class="line">		<span class="type">const</span> FTextRange Range = Run.<span class="built_in">GetTextRange</span>();</span><br><span class="line"></span><br><span class="line">		FVector2D SliceSize;</span><br><span class="line">		FVector2D SliceSizeWithoutTrailingWhitespace;</span><br><span class="line">		int32 StopIndex = PreviousBreak;</span><br><span class="line"></span><br><span class="line">		WhitespaceStopIndex = StopIndex = FMath::<span class="built_in">Min</span>( Range.EndIndex, CurrentBreak );</span><br><span class="line">		int32 BeginIndex = FMath::<span class="built_in">Max</span>( PreviousBreak, Range.BeginIndex );</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>( WhitespaceStopIndex &gt; BeginIndex &amp;&amp; FText::<span class="built_in">IsWhitespace</span>( (*Line.Text)[ WhitespaceStopIndex - <span class="number">1</span> ] ) )</span><br><span class="line">		&#123;</span><br><span class="line">			--WhitespaceStopIndex;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ( BeginIndex == StopIndex )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// This slice is empty, no need to adjust anything</span></span><br><span class="line">			SliceSize = SliceSizeWithoutTrailingWhitespace = FVector2D::ZeroVector;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( BeginIndex == WhitespaceStopIndex )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// This slice contains only whitespace, no need to adjust SliceSizeWithoutTrailingWhitespace</span></span><br><span class="line">			SliceSize = Run.<span class="built_in">Measure</span>( BeginIndex, StopIndex, Scale, RunTextContext );</span><br><span class="line">			SliceSizeWithoutTrailingWhitespace = FVector2D::ZeroVector;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( WhitespaceStopIndex != StopIndex )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// This slice contains trailing whitespace, measure the text size, then add on the whitespace size</span></span><br><span class="line">			SliceSize = SliceSizeWithoutTrailingWhitespace = Run.<span class="built_in">Measure</span>( BeginIndex, WhitespaceStopIndex, Scale, RunTextContext );</span><br><span class="line">			<span class="type">const</span> <span class="type">float</span> WhitespaceWidth = Run.<span class="built_in">Measure</span>( WhitespaceStopIndex, StopIndex, Scale, RunTextContext ).X;</span><br><span class="line">			SliceSize.X += WhitespaceWidth;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// We also need to measure the width of the first piece of trailing whitespace</span></span><br><span class="line">			<span class="keyword">if</span> ( WhitespaceStopIndex + <span class="number">1</span> == StopIndex )</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// Only have one piece of whitespace</span></span><br><span class="line">				FirstTrailingWhitespaceCharWidth = WhitespaceWidth;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// Deliberately use the run version of Measure as we don&#x27;t want the run model to cache this measurement since it may be out of order and break the binary search</span></span><br><span class="line">				FirstTrailingWhitespaceCharWidth = Run.<span class="built_in">GetRun</span>()-&gt;<span class="built_in">Measure</span>( WhitespaceStopIndex, WhitespaceStopIndex + <span class="number">1</span>, Scale, RunTextContext ).X;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// This slice contains no whitespace, both sizes are the same and can use the same measurement</span></span><br><span class="line">			SliceSize = SliceSizeWithoutTrailingWhitespace = Run.<span class="built_in">Measure</span>( BeginIndex, StopIndex, Scale, RunTextContext );</span><br><span class="line">		&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <code>CreateBreakCandidate()</code> function is quite big size, about 200 lines. But the core of function is to calculate a size of slice. Do you remember the variable <code>CurrentBreak</code> that indicates where each slice ends ? Here, the function make a slice according to <code>CurrentBreak</code> and trim it. Trimming happens in <code>while</code> statement, which decreases the <code>WhitespaceStopIndex</code> until it indicates an end of last word.</p>
<img src="/2022/03/22/how-the-text-wrap-works-in-unrealengine/04.png" class="">

<p>The <code>WhitespaceStopIndex</code> would be 4 in our test text. That is because the index of first whitespace is 4 in <code>Text Block Test</code>. Eventually, we will enter the function <code>Measure()</code> as the slice is not empty. The only case that <code>Measure()</code> not called is when <code>BeginIndex == StopIndex</code> is true, in other words <code>CurrentBreak == 0</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TextLayout.cpp</span></span><br><span class="line">FVector2D FTextLayout::FRunModel::<span class="built_in">Measure</span>(int32 BeginIndex, int32 EndIndex, <span class="type">float</span> InScale, <span class="type">const</span> FRunTextContext&amp; InTextContext)</span><br><span class="line">&#123;</span><br><span class="line">	FVector2D Size = Run-&gt;<span class="built_in">Measure</span>(BeginIndex, EndIndex, InScale, InTextContext);</span><br><span class="line"></span><br><span class="line">	MeasuredRanges.<span class="built_in">Add</span>( <span class="built_in">FTextRange</span>( BeginIndex, EndIndex ) );</span><br><span class="line">	MeasuredRangeSizes.<span class="built_in">Add</span>(Size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SlateTextRun.cpp</span></span><br><span class="line"><span class="function">FVector2D <span class="title">FSlateTextRun::Measure</span><span class="params">( int32 BeginIndex, int32 EndIndex, <span class="type">float</span> Scale, <span class="type">const</span> FRunTextContext&amp; TextContext )</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">const</span> FVector2D <span class="title">ShadowOffsetToApply</span><span class="params">((EndIndex == Range.EndIndex) ? FMath::Abs(Style.ShadowOffset.X * Scale) : <span class="number">0.0f</span>, FMath::Abs(Style.ShadowOffset.Y * Scale))</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Offset the measured shaped text by the outline since the outline was not factored into the size of the text</span></span><br><span class="line">	<span class="comment">// Need to add the outline offsetting to the beginning and the end because it surrounds both sides.</span></span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> ScaledOutlineSize = Style.Font.OutlineSettings.OutlineSize * Scale;</span><br><span class="line">	<span class="function"><span class="type">const</span> FVector2D <span class="title">OutlineSizeToApply</span><span class="params">((BeginIndex == Range.BeginIndex ? ScaledOutlineSize : <span class="number">0</span>) + (EndIndex == Range.EndIndex ? ScaledOutlineSize : <span class="number">0</span>), ScaledOutlineSize)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (EndIndex - BeginIndex == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">FVector2D</span>(<span class="number">0</span>, <span class="built_in">GetMaxHeight</span>(Scale)) + ShadowOffsetToApply + OutlineSizeToApply;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use the full text range (rather than the run range) so that text that spans runs will still be shaped correctly</span></span><br><span class="line">	<span class="keyword">return</span> ShapedTextCacheUtil::<span class="built_in">MeasureShapedText</span>(TextContext.ShapedTextCache, <span class="built_in">FCachedShapedTextKey</span>(<span class="built_in">FTextRange</span>(<span class="number">0</span>, Text-&gt;<span class="built_in">Len</span>()), Scale, TextContext, Style.Font), <span class="built_in">FTextRange</span>(BeginIndex, EndIndex), **Text) + ShadowOffsetToApply + OutlineSizeToApply;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We will get a FVector2D from <code>FSlateTextRun::Measure()</code>, which is the size of slice. The code <code>Run-&gt;Measure()</code> is the same with calling <code>ShapedTextCacheUtil::MeasureShapedText()</code> when you are using a TextBlock. Calculating shadow offset is not important in this post, so we need to focus on <code>ShapedTextCacheUtil::MeasureShapedText()</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ShapedTextFwd.h</span></span><br><span class="line"><span class="keyword">typedef</span> TSharedRef&lt;<span class="type">const</span> FShapedGlyphSequence&gt; FShapedGlyphSequenceRef;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ShapedTextCache.cpp</span></span><br><span class="line"><span class="function">FVector2D <span class="title">ShapedTextCacheUtil::MeasureShapedText</span><span class="params">(<span class="type">const</span> FShapedTextCacheRef&amp; InShapedTextCache, <span class="type">const</span> FCachedShapedTextKey&amp; InRunKey, <span class="type">const</span> FTextRange&amp; InMeasureRange, <span class="type">const</span> TCHAR* InText)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Get the shaped text for the entire run and try and take a sub-measurement from it - this can help minimize the amount of text shaping that needs to be done when measuring text</span></span><br><span class="line">	FShapedGlyphSequenceRef ShapedText = InShapedTextCache-&gt;<span class="built_in">FindOrAddShapedText</span>(InRunKey, InText);</span><br><span class="line"></span><br><span class="line">	TOptional&lt;int32&gt; MeasuredWidth = ShapedText-&gt;<span class="built_in">GetMeasuredWidth</span>(InMeasureRange.BeginIndex, InMeasureRange.EndIndex);</span><br><span class="line">	<span class="keyword">if</span> (!MeasuredWidth.<span class="built_in">IsSet</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		FCachedShapedTextKey MeasureKey = InRunKey;</span><br><span class="line">		MeasureKey.TextRange = InMeasureRange;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Couldn&#x27;t measure the sub-range, try and measure from a shape of the specified range</span></span><br><span class="line">		ShapedText = InShapedTextCache-&gt;<span class="built_in">FindOrAddShapedText</span>(MeasureKey, InText);</span><br><span class="line">		MeasuredWidth = ShapedText-&gt;<span class="built_in">GetMeasuredWidth</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">check</span>(MeasuredWidth.<span class="built_in">IsSet</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">FVector2D</span>(MeasuredWidth.<span class="built_in">GetValue</span>(), ShapedText-&gt;<span class="built_in">GetMaxTextHeight</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As you can see, the <code>FShapedGlyphSequenceRef</code> is a shared reference of <code>FShapedGlyphSequence</code>. Then, what the hell is <code>FShapedGlyphSequence</code> ? And what it does ?</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FShapedGlyphSequenceRef <span class="title">FShapedTextCache::FindOrAddShapedText</span><span class="params">(<span class="type">const</span> FCachedShapedTextKey&amp; InKey, <span class="type">const</span> TCHAR* InText)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FShapedGlyphSequencePtr ShapedText = <span class="built_in">FindShapedText</span>(InKey);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ShapedText.<span class="built_in">IsValid</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		ShapedText = <span class="built_in">AddShapedText</span>(InKey, InText);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ShapedText.<span class="built_in">ToSharedRef</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FShapedGlyphSequencePtr <span class="title">FShapedTextCache::FindShapedText</span><span class="params">(<span class="type">const</span> FCachedShapedTextKey&amp; InKey)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FShapedGlyphSequencePtr ShapedText = CachedShapedText.<span class="built_in">FindRef</span>(InKey);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ShapedText.<span class="built_in">IsValid</span>() &amp;&amp; !ShapedText-&gt;<span class="built_in">IsDirty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ShapedText;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FShapedGlyphSequenceRef <span class="title">FShapedTextCache::AddShapedText</span><span class="params">(<span class="type">const</span> FCachedShapedTextKey&amp; InKey, FShapedGlyphSequenceRef InShapedText)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CachedShapedText.<span class="built_in">Add</span>(InKey, InShapedText);</span><br><span class="line">	<span class="keyword">return</span> InShapedText;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>First, engine tries to find if there is already existing one. If not, creates new one and insert it into the cache.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FontCache.h</span></span><br><span class="line"><span class="comment">/** Information for rendering a shaped text sequence */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SLATECORE_API</span> FShapedGlyphSequence</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/** Array of glyphs in this sequence. This data will be ordered so that you can iterate and draw left-to-right, which means it will be backwards for right-to-left languages */</span></span><br><span class="line">	TArray&lt;FShapedGlyphEntry&gt; GlyphsToRender;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Information for rendering one glyph in a shaped text sequence */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FShapedGlyphEntry</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/** The index of this glyph from the source text. The source indices may skip characters if the sequence contains ligatures, additionally, some characters produce multiple glyphs leading to duplicate source indices */</span></span><br><span class="line">	int32 SourceIndex = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/** The amount to advance in X before drawing the next glyph in the sequence */</span></span><br><span class="line">	int16 XAdvance = <span class="number">0</span>;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line"><span class="comment">// FontCache.cpp</span></span><br><span class="line">FShapedGlyphSequence::<span class="built_in">FShapedGlyphSequence</span>(TArray&lt;FShapedGlyphEntry&gt; InGlyphsToRender, <span class="type">const</span> int16 InTextBaseline, <span class="type">const</span> uint16 InMaxTextHeight, <span class="type">const</span> UObject* InFontMaterial, <span class="type">const</span> FFontOutlineSettings&amp; InOutlineSettings, <span class="type">const</span> FSourceTextRange&amp; InSourceTextRange)</span><br><span class="line">	: <span class="built_in">GlyphsToRender</span>(<span class="built_in">MoveTemp</span>(InGlyphsToRender))</span><br><span class="line">	, <span class="built_in">TextBaseline</span>(InTextBaseline)</span><br><span class="line">	, <span class="built_in">MaxTextHeight</span>(InMaxTextHeight)</span><br><span class="line">	, <span class="built_in">FontMaterial</span>(InFontMaterial)</span><br><span class="line">	, <span class="built_in">OutlineSettings</span>(InOutlineSettings)</span><br><span class="line">	, <span class="built_in">SequenceWidth</span>(<span class="number">0</span>)</span><br><span class="line">	, <span class="built_in">GlyphFontFaces</span>()</span><br><span class="line">	, <span class="built_in">SourceIndicesToGlyphData</span>(InSourceTextRange)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> int32 NumGlyphsToRender = GlyphsToRender.<span class="built_in">Num</span>();</span><br><span class="line">	<span class="keyword">for</span> (int32 CurrentGlyphIndex = <span class="number">0</span>; CurrentGlyphIndex &lt; NumGlyphsToRender; ++CurrentGlyphIndex)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> FShapedGlyphEntry&amp; CurrentGlyph = GlyphsToRender[CurrentGlyphIndex];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Track unique font faces</span></span><br><span class="line">		<span class="keyword">if</span> (CurrentGlyph.FontFaceData-&gt;FontFace.<span class="built_in">IsValid</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			GlyphFontFaces.<span class="built_in">AddUnique</span>(CurrentGlyph.FontFaceData-&gt;FontFace);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Update the measured width</span></span><br><span class="line">		SequenceWidth += CurrentGlyph.XAdvance;</span><br><span class="line">		...</span><br></pre></td></tr></table></figure>

<p>The <code>FShapedGlyphSequence</code> has a TArray of <code>FShapedGlyphEntry</code>. And the <code>FShapedGlyphEntry</code> has several properties such as <code>SourceIndex</code> and <code>XAdvance</code>. Looks like the <code>FShapedGlyphEntry</code> has properties responding each character in text, and the <code>FShapedGlyphSequence</code> has properties responding whole text. The properties are for how to render the text appropriately. So here, we can regard the term <code>Glyph</code> as one single character.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SlateTextShaper.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FSlateTextShaper::PerformKerningOnlyTextShaping</span><span class="params">(<span class="type">const</span> TCHAR* InText, <span class="type">const</span> int32 InTextStart, <span class="type">const</span> int32 InTextLen, <span class="type">const</span> FSlateFontInfo&amp; InFontInfo, <span class="type">const</span> <span class="type">float</span> InFontScale, TArray&lt;FShapedGlyphEntry&gt;&amp; OutGlyphsToRender)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span> (int32 SequenceCharIndex = <span class="number">0</span>; SequenceCharIndex &lt; KerningOnlyTextSequenceEntry.TextLength; ++SequenceCharIndex)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> int32 CurrentCharIndex = KerningOnlyTextSequenceEntry.TextStartIndex + SequenceCharIndex;</span><br><span class="line">		<span class="type">const</span> TCHAR CurrentChar = InText[CurrentCharIndex];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">InsertSubstituteGlyphs</span>(InText, CurrentCharIndex, ShapedGlyphFaceData, AdvanceCache, OutGlyphsToRender, LetterSpacingScaled))</span><br><span class="line">		&#123;</span><br><span class="line">			uint32 GlyphIndex = <span class="built_in">FT_Get_Char_Index</span>(KerningOnlyTextSequenceEntry.FaceAndMemory-&gt;<span class="built_in">GetFace</span>(), CurrentChar);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// If the given font can&#x27;t render that character (as the fallback font may be missing), try again with the fallback character</span></span><br><span class="line">			<span class="keyword">if</span> (CurrentChar != <span class="number">0</span> &amp;&amp; GlyphIndex == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				GlyphIndex = <span class="built_in">FT_Get_Char_Index</span>(KerningOnlyTextSequenceEntry.FaceAndMemory-&gt;<span class="built_in">GetFace</span>(), SlateFontRendererUtils::InvalidSubChar);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			int16 XAdvance = <span class="number">0</span>;</span><br><span class="line">			&#123;</span><br><span class="line">				FT_Fixed CachedAdvanceData = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> (AdvanceCache-&gt;<span class="built_in">FindOrCache</span>(GlyphIndex, CachedAdvanceData))</span><br><span class="line">				&#123;</span><br><span class="line">					XAdvance = FreeTypeUtils::<span class="built_in">Convert26Dot6ToRoundedPixel</span>&lt;int16&gt;((CachedAdvanceData + (<span class="number">1</span>&lt;&lt;<span class="number">9</span>)) &gt;&gt; <span class="number">10</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="type">const</span> int32 CurrentGlyphEntryIndex = OutGlyphsToRender.<span class="built_in">AddDefaulted</span>();</span><br><span class="line">			FShapedGlyphEntry&amp; ShapedGlyphEntry = OutGlyphsToRender[CurrentGlyphEntryIndex];</span><br><span class="line">			ShapedGlyphEntry.FontFaceData = ShapedGlyphFaceData;</span><br><span class="line">			ShapedGlyphEntry.GlyphIndex = GlyphIndex;</span><br><span class="line">			ShapedGlyphEntry.SourceIndex = CurrentCharIndex;</span><br><span class="line">			ShapedGlyphEntry.XAdvance = XAdvance;</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>Usually, the <code>XAdvande</code> is determined at <code>FSlateTextShaper::PerformKerningOnlyTextShaping()</code>. Engine uses <a target="_blank" rel="noopener" href="https://gitlab.freedesktop.org/freetype/freetype">the FreeType library</a> for getting a estimated size of character when it rendered. The <code>GlyphIndex</code> is calculated based on font and character value.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FFreeTypeAdvanceCache::FindOrCache</span><span class="params">(<span class="type">const</span> uint32 InGlyphIndex, FT_Fixed&amp; OutCachedAdvance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Try and find the advance from the cache...</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> FT_Fixed* FoundCachedAdvance = AdvanceMap.<span class="built_in">Find</span>(InGlyphIndex);</span><br><span class="line">		<span class="keyword">if</span> (FoundCachedAdvance)</span><br><span class="line">		&#123;</span><br><span class="line">			OutCachedAdvance = *FoundCachedAdvance;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FreeTypeUtils::<span class="built_in">ApplySizeAndScale</span>(Face, FontSize, FontScale);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// No cached data, go ahead and add an entry for it...</span></span><br><span class="line">	<span class="type">const</span> FT_Error Error = <span class="built_in">FT_Get_Advance</span>(Face, InGlyphIndex, LoadFlags, &amp;OutCachedAdvance);</span><br><span class="line">	<span class="keyword">if</span> (Error == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">FT_IS_SCALABLE</span>(Face) &amp;&amp; <span class="built_in">FT_HAS_FIXED_SIZES</span>(Face))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// Fixed size fonts don&#x27;t support scaling, but we calculated the scale to use for the glyph in ApplySizeAndScale</span></span><br><span class="line">			OutCachedAdvance = <span class="built_in">FT_MulFix</span>(OutCachedAdvance, ((LoadFlags &amp; FT_LOAD_VERTICAL_LAYOUT) ? Face-&gt;size-&gt;metrics.y_scale : Face-&gt;size-&gt;metrics.x_scale));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		AdvanceMap.<span class="built_in">Add</span>(InGlyphIndex, OutCachedAdvance);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The code <code>AdvanceCache-&gt;FindOrCache(GlyphIndex, CachedAdvanceData)</code> finds at cache, but it creates new one and cache it if could not find. The <code>FT_Get_Advance()</code> returns the result with parameter <code>&amp;OutCachedAdvance</code>. We can get a size of single character through the function because the value <code>GlyphIndex</code> includes information of font and character value.</p>
<img src="/2022/03/22/how-the-text-wrap-works-in-unrealengine/05.png" class="">

<p>In our test text <code>Text Block Test</code>, the result is like below:</p>
<table>
<thead>
<tr>
<th>Index</th>
<th>Character</th>
<th>GlyphIndex</th>
<th>XAdvance</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td><code>T</code></td>
<td>55</td>
<td>18</td>
</tr>
<tr>
<td>1</td>
<td><code>e</code></td>
<td>72</td>
<td>17</td>
</tr>
<tr>
<td>2</td>
<td><code>x</code></td>
<td>91</td>
<td>16</td>
</tr>
<tr>
<td>3</td>
<td><code>t</code></td>
<td>87</td>
<td>11</td>
</tr>
<tr>
<td>4</td>
<td><code> </code></td>
<td>3</td>
<td>8</td>
</tr>
<tr>
<td>5</td>
<td><code>B</code></td>
<td>37</td>
<td>20</td>
</tr>
<tr>
<td>6</td>
<td><code>l</code></td>
<td>79</td>
<td>9</td>
</tr>
<tr>
<td>7</td>
<td><code>o</code></td>
<td>82</td>
<td>18</td>
</tr>
<tr>
<td>8</td>
<td><code>c</code></td>
<td>70</td>
<td>17</td>
</tr>
<tr>
<td>9</td>
<td><code>k</code></td>
<td>78</td>
<td>17</td>
</tr>
<tr>
<td>10</td>
<td><code> </code></td>
<td>3</td>
<td>8</td>
</tr>
<tr>
<td>11</td>
<td><code>T</code></td>
<td>55</td>
<td>18</td>
</tr>
<tr>
<td>12</td>
<td><code>e</code></td>
<td>72</td>
<td>17</td>
</tr>
<tr>
<td>13</td>
<td><code>s</code></td>
<td>86</td>
<td>17</td>
</tr>
<tr>
<td>14</td>
<td><code>t</code></td>
<td>87</td>
<td>11</td>
</tr>
</tbody></table>
<img src="/2022/03/22/how-the-text-wrap-works-in-unrealengine/07.png" class="">

<p>You can see that the same character has the same XAdvance value. For example, The character <code>T</code> has <code>55</code> of GlyphIndex and <code>18</code> of XAdvance. Go back to the <code>ShapedTextCacheUtil::MeasureShapedText()</code>, that is why the <code>MeasuredWidth</code> has a value of <code>220 ≒ 222 = 18 + 17 + ... + 17 + 11</code>. The difference <code>2</code> occurs by the kerning.</p>
<img src="/2022/03/22/how-the-text-wrap-works-in-unrealengine/06.png" class="">

<p>The final width may differ a little bit because some combination of characters need a kerning. For example, though <code>e</code> and <code>k</code> have the same XAdvance value <code>17</code>, a combination <code>Te</code> has a small size than a combination <code>Tk</code>. Because in the combination <code>Te</code>, <code>e</code> can stick to <code>T</code> closer than <code>k</code> in <code>Tk</code>. In other words, a character <code>T</code> can have XAdvance of <code>17</code> in the combinations such as <code>Ta/Tc/Td</code>, and so on. Otherwise such as <code>Tb/Tf/Th</code>, it can have XAdvance of <code>18</code>.</p>
<h1 id="Break-lines-3-3-Creating-lines-with-wrapping"><a href="#Break-lines-3-3-Creating-lines-with-wrapping" class="headerlink" title="Break lines (3/3); Creating lines with wrapping"></a><em><code>Break lines (3/3); Creating lines with wrapping</code></em></h1><img src="/2022/03/22/how-the-text-wrap-works-in-unrealengine/08.png" class="">

<p>Go back to the <code>FTextLayout::CreateLineWrappingCache()</code>, now we can wrap text according to size (exactly, width) of each slice. All slices are stored at the container <code>BreakCandidates</code>. In our test text <code>Text Block Test</code>, the result is like below:</p>
<table>
<thead>
<tr>
<th>BreakCandidates</th>
<th>ActualRange</th>
<th>TrimmedRange</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td><code>Text </code> [0, 5)</td>
<td><code>Text</code> [0, 4)</td>
</tr>
<tr>
<td>1</td>
<td><code>Block </code> [5, 11)</td>
<td><code>Block</code> [5, 10)</td>
</tr>
<tr>
<td>2</td>
<td><code>Test</code> [11, 15)</td>
<td><code>Test</code> [11, 15)</td>
</tr>
</tbody></table>
<p>※ <code>[0, 5)</code> is equal to <code>[0, 4]</code></p>
<p>Do you remember there is a code calls <code>FTextLayout::FlowLineLayout()</code> in <code>FTextLayout::FlowLayout()</code> ?</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FTextLayout::FlowLineLayout</span><span class="params">(<span class="type">const</span> int32 LineModelIndex, <span class="type">const</span> <span class="type">float</span> WrappingDrawWidth, TArray&lt;TSharedRef&lt;ILayoutBlock&gt;&gt;&amp; SoftLine)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="type">float</span> CurrentWidth = <span class="number">0.0f</span>;</span><br><span class="line">	<span class="keyword">for</span> (int32 BreakIndex = <span class="number">0</span>; BreakIndex &lt; LineModel.BreakCandidates.<span class="built_in">Num</span>(); BreakIndex++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> FBreakCandidate&amp; Break = LineModel.BreakCandidates[ BreakIndex ];</span><br><span class="line"></span><br><span class="line">		<span class="type">const</span> <span class="type">bool</span> IsLastBreak = BreakIndex + <span class="number">1</span> == LineModel.BreakCandidates.<span class="built_in">Num</span>();</span><br><span class="line">		<span class="type">const</span> <span class="type">bool</span> IsFirstBreakOnSoftLine = CurrentWidth == <span class="number">0.0f</span>;</span><br><span class="line">		<span class="type">const</span> int8 Kerning = ( IsFirstBreakOnSoftLine ) ? Break.Kerning : <span class="number">0</span>;</span><br><span class="line">		<span class="type">const</span> <span class="type">bool</span> BreakDoesFit = CurrentWidth + Break.ActualSize.X + Kerning &lt;= WrappingDrawWidth;</span><br><span class="line">		<span class="type">const</span> <span class="type">bool</span> BreakWithoutTrailingWhitespaceDoesFit = CurrentWidth + Break.TrimmedWidth + Kerning &lt;= WrappingDrawWidth;</span><br><span class="line">		...</span><br></pre></td></tr></table></figure>

<p>Here, we accumulate a width of each BreakCandidate on <code>CurrentWidth</code>. And wrapping text occurs whenever <code>CurrentWidth</code> almost reaches to <code>WrappingDrawWidth</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( !BreakDoesFit || IsLastBreak )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">bool</span> IsFirstBreak = BreakIndex == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> FBreakCandidate&amp; FinalBreakOnSoftLine = ( !IsFirstBreak &amp;&amp; !IsFirstBreakOnSoftLine &amp;&amp; !BreakWithoutTrailingWhitespaceDoesFit ) ? LineModel.BreakCandidates[ --BreakIndex ] : Break;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// We want the wrapped line width to contain the first piece of trailing whitespace for a line, however we only do this if we have trailing whitespace</span></span><br><span class="line">	<span class="comment">// otherwise very long non-breaking words can cause the wrapped line width to expand beyond the desired wrap width</span></span><br><span class="line">	<span class="type">float</span> WrappedLineWidth = CurrentWidth;</span><br><span class="line">	<span class="keyword">if</span> ( BreakWithoutTrailingWhitespaceDoesFit )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// This break has trailing whitespace</span></span><br><span class="line">		WrappedLineWidth += ( FinalBreakOnSoftLine.TrimmedWidth + FinalBreakOnSoftLine.FirstTrailingWhitespaceCharWidth );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// This break is longer than the wrapping point, so make sure and clamp the line size to the given wrapping width</span></span><br><span class="line">		WrappedLineWidth += FinalBreakOnSoftLine.ActualSize.X;</span><br><span class="line">		WrappedLineWidth = FMath::<span class="built_in">Min</span>(WrappedLineWidth, WrappingDrawWidth);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We want wrapped lines to ignore any trailing whitespace when justifying</span></span><br><span class="line">	<span class="comment">// If FinalBreakOnSoftLine isn&#x27;t the current Break, then the size of FinalBreakOnSoftLine (including its trailing whitespace) will have already</span></span><br><span class="line">	<span class="comment">// been added to CurrentWidth, so we need to remove that again before adding the trimmed width (which is the width we should justify with)</span></span><br><span class="line">	<span class="comment">// We should not attempt to adjust the last break on a soft-line as that might have explicit trailing whitespace</span></span><br><span class="line">	TOptional&lt;<span class="type">float</span>&gt; JustifiedLineWidth;</span><br><span class="line">	<span class="keyword">if</span> ( &amp;FinalBreakOnSoftLine != &amp;LineModel.BreakCandidates.<span class="built_in">Last</span>() )</span><br><span class="line">	&#123;</span><br><span class="line">		JustifiedLineWidth = CurrentWidth - (&amp;FinalBreakOnSoftLine == &amp;Break ? <span class="number">0.0f</span> : FinalBreakOnSoftLine.ActualSize.X) + FinalBreakOnSoftLine.TrimmedWidth;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CreateLineViewBlocks</span>( LineModelIndex, FinalBreakOnSoftLine.ActualRange.EndIndex, WrappedLineWidth, JustifiedLineWidth, <span class="comment">/*OUT*/</span>CurrentRunIndex, <span class="comment">/*OUT*/</span>CurrentRendererIndex, <span class="comment">/*OUT*/</span>PreviousBlockEnd, SoftLine );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( CurrentRunIndex &lt; LineModel.Runs.<span class="built_in">Num</span>() &amp;&amp; FinalBreakOnSoftLine.ActualRange.EndIndex == LineModel.Runs[ CurrentRunIndex ].<span class="built_in">GetTextRange</span>().EndIndex )</span><br><span class="line">	&#123;</span><br><span class="line">		++CurrentRunIndex;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PreviousBlockEnd = FinalBreakOnSoftLine.ActualRange.EndIndex;</span><br><span class="line"></span><br><span class="line">	CurrentWidth = <span class="number">0.0f</span>;</span><br><span class="line">	SoftLine.<span class="built_in">Reset</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>Usually, when wrapping text needed, the codes above would be executed. <code>FinalBreakOnSoftLine</code> indicates the BreakCandidate that needs a new line after itself. In our test text <code>Text Block Test</code>, <code>Text </code> could be assigned.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FTextLayout::CreateLineViewBlocks</span><span class="params">( int32 LineModelIndex, <span class="type">const</span> int32 StopIndex, <span class="type">const</span> <span class="type">float</span> WrappedLineWidth, <span class="type">const</span> TOptional&lt;<span class="type">float</span>&gt;&amp; JustificationWidth, int32&amp; OutRunIndex, int32&amp; OutRendererIndex, int32&amp; OutPreviousBlockEnd, TArray&lt; TSharedRef&lt; ILayoutBlock &gt; &gt;&amp; OutSoftLine )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// Add the new block</span></span><br><span class="line">	&#123;</span><br><span class="line">		FBlockDefinition BlockDefine;</span><br><span class="line">		BlockDefine.ActualRange = <span class="built_in">FTextRange</span>(BlockBeginIndex, BlockStopIndex);</span><br><span class="line">		BlockDefine.Renderer = BlockRenderer;</span><br><span class="line"></span><br><span class="line">		OutSoftLine.<span class="built_in">Add</span>( Run.<span class="built_in">CreateBlock</span>( BlockDefine, Scale, <span class="built_in">FLayoutBlockTextContext</span>(RunTextContext, BlockTextDirection) ) );</span><br><span class="line">		OutPreviousBlockEnd = BlockStopIndex;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Update the soft line bounds based on this new block (needed within this loop due to bi-directional text, as the extents of the line array are not always the start and end of the range)</span></span><br><span class="line">		<span class="type">const</span> FTextRange&amp; BlockRange = OutSoftLine.<span class="built_in">Last</span>()-&gt;<span class="built_in">GetTextRange</span>();</span><br><span class="line">		SoftLineRange.BeginIndex = FMath::<span class="built_in">Min</span>(SoftLineRange.BeginIndex, BlockRange.BeginIndex);</span><br><span class="line">		SoftLineRange.EndIndex   = FMath::<span class="built_in">Max</span>(SoftLineRange.EndIndex, BlockRange.EndIndex);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	FTextLayout::FLineView LineView;</span><br><span class="line">	LineView.Offset = CurrentOffset;</span><br><span class="line">	LineView.Size = LineSize;</span><br><span class="line">	LineView.TextHeight = UnscaleLineHeight;</span><br><span class="line">	LineView.JustificationWidth = JustificationWidth.<span class="built_in">Get</span>(LineView.Size.X);</span><br><span class="line">	LineView.Range = SoftLineRange;</span><br><span class="line">	LineView.TextBaseDirection = LineModel.TextBaseDirection;</span><br><span class="line">	LineView.ModelIndex = LineModelIndex;</span><br><span class="line">	LineView.Blocks.<span class="built_in">Append</span>( OutSoftLine );</span><br><span class="line"></span><br><span class="line">	LineViews.<span class="built_in">Add</span>( LineView );</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>The function <code>FTextLayout::CreateLineViewBlocks()</code> creates new <code>FTextLayout::FLineView</code> and adds it into initialized <code>LineViews</code>. We already cleared the <code>LineViews</code> at the function <code>FTextLayout::ClearView()</code>. In our test txt, after all process, the <code>LineViews</code> will have the value like below:</p>
<table>
<thead>
<tr>
<th>LineViews</th>
<th>Range</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>[0, 5)</td>
</tr>
<tr>
<td>1</td>
<td>[5, 11)</td>
</tr>
<tr>
<td>2</td>
<td>[11, 15)</td>
</tr>
</tbody></table>
<img src="/2022/03/22/how-the-text-wrap-works-in-unrealengine/09.png" class="">

<p>Finally, we found that the result of wrapping text. All of prerequisites are for splitting a text. Now we understand how the text can be wrapped in UnrealEngine.</p>
<h1 id="Wrap-up"><a href="#Wrap-up" class="headerlink" title="Wrap-up"></a><em><code>Wrap-up</code></em></h1><p>Text wrapping in UnrealEngine can be divided into 3 major steps.</p>
<ol>
<li><p><code>Separating a text into slices</code><br>Find where each word ends using ICU library.<br>Separate text into slices based on the indices.</p>
</li>
<li><p><code>Measuring size of each slice</code><br>Estimate size of rendered character using FreeType library.<br>Apply several modifications such as kerning, shadow, and so on.</p>
</li>
<li><p><code>Creating lines with wrapping</code><br>Add width until it reaches the wrapping width.<br>When it reaches, create new line.</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baemincheon.github.io/2022/03/22/how-the-text-wrap-works-in-unrealengine/" data-id="cmfflh8b4000u2sqm761vejzp" class="article-share-link">Share</a>
      
        <a href="https://baemincheon.github.io/2022/03/22/how-the-text-wrap-works-in-unrealengine/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TextBlock/" rel="tag">TextBlock</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TextWrap/" rel="tag">TextWrap</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UnrealEngine/" rel="tag">UnrealEngine</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/07/28/how-the-rich-text-block-works-in-unrealengine/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          How the RichTextBlock works in UnrealEngine (part.1)
        
      </div>
    </a>
  
  
    <a href="/2022/02/22/how-to-rename-your-project-in-unrealengine/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">How to rename your project in UnrealEngine</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/" rel="tag">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/About/" rel="tag">About</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Animation/" rel="tag">Animation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Blueprint/" rel="tag">Blueprint</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CPP/" rel="tag">CPP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cat/" rel="tag">Cat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Copy/" rel="tag">Copy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DigitalOcean/" rel="tag">DigitalOcean</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GCC/" rel="tag">GCC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GoogleAnalytics/" rel="tag">GoogleAnalytics</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Home/" rel="tag">Home</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Iptime/" rel="tag">Iptime</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lecture/" rel="tag">Lecture</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MSVC/" rel="tag">MSVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Migration/" rel="tag">Migration</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Natvis/" rel="tag">Natvis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/" rel="tag">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Perforce/" rel="tag">Perforce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Retargeting/" rel="tag">Retargeting</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Retrospection/" rel="tag">Retrospection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RichTextBlock/" rel="tag">RichTextBlock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/" rel="tag">STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TextBlock/" rel="tag">TextBlock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TextWrap/" rel="tag">TextWrap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/" rel="tag">Ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UnrealEngine/" rel="tag">UnrealEngine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WSL/" rel="tag">WSL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows/" rel="tag">Windows</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AI/" style="font-size: 10px;">AI</a> <a href="/tags/About/" style="font-size: 10px;">About</a> <a href="/tags/Animation/" style="font-size: 10px;">Animation</a> <a href="/tags/Blueprint/" style="font-size: 13.33px;">Blueprint</a> <a href="/tags/CPP/" style="font-size: 13.33px;">CPP</a> <a href="/tags/Cat/" style="font-size: 10px;">Cat</a> <a href="/tags/Copy/" style="font-size: 10px;">Copy</a> <a href="/tags/DigitalOcean/" style="font-size: 10px;">DigitalOcean</a> <a href="/tags/GCC/" style="font-size: 10px;">GCC</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/GoogleAnalytics/" style="font-size: 10px;">GoogleAnalytics</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Home/" style="font-size: 10px;">Home</a> <a href="/tags/Iptime/" style="font-size: 10px;">Iptime</a> <a href="/tags/Lecture/" style="font-size: 10px;">Lecture</a> <a href="/tags/Linux/" style="font-size: 13.33px;">Linux</a> <a href="/tags/MSVC/" style="font-size: 10px;">MSVC</a> <a href="/tags/Migration/" style="font-size: 10px;">Migration</a> <a href="/tags/Natvis/" style="font-size: 10px;">Natvis</a> <a href="/tags/Network/" style="font-size: 10px;">Network</a> <a href="/tags/Perforce/" style="font-size: 13.33px;">Perforce</a> <a href="/tags/Retargeting/" style="font-size: 10px;">Retargeting</a> <a href="/tags/Retrospection/" style="font-size: 16.67px;">Retrospection</a> <a href="/tags/RichTextBlock/" style="font-size: 10px;">RichTextBlock</a> <a href="/tags/STL/" style="font-size: 10px;">STL</a> <a href="/tags/TextBlock/" style="font-size: 13.33px;">TextBlock</a> <a href="/tags/TextWrap/" style="font-size: 10px;">TextWrap</a> <a href="/tags/Ubuntu/" style="font-size: 10px;">Ubuntu</a> <a href="/tags/UnrealEngine/" style="font-size: 20px;">UnrealEngine</a> <a href="/tags/WSL/" style="font-size: 13.33px;">WSL</a> <a href="/tags/Windows/" style="font-size: 10px;">Windows</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/09/">September 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/09/09/introduction-to-ai-with-xor-problem/">introduction to AI with XOR problem</a>
          </li>
        
          <li>
            <a href="/2024/05/13/difference-between-copy-and-cat-in-combining-files/">Difference between copy and cat in combining files</a>
          </li>
        
          <li>
            <a href="/2023/12/04/migration-from-perforce-into-git-in-windows/">Migration from Perforce into Git in Windows</a>
          </li>
        
          <li>
            <a href="/2023/04/10/conversion-from-universal-analytics-into-google-analytics-4/">Conversion from UA into GA4</a>
          </li>
        
          <li>
            <a href="/2022/12/12/promotion-for-online-lecture-of-unrealengine-01/">The promotion for online lecture of UnrealEngine</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 MinCheon Bae<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/2020/02/03/home-page/index.html" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'let-us-go-abroad';
  
  var disqus_url = 'https://baemincheon.github.io/2022/03/22/how-the-text-wrap-works-in-unrealengine/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>